#!/usr/bin/env bash
#
# tools/gen-crt-min-versions.sh
# Regenerates  cmake/CRTMinVersions.cmake  in the current repository.
# ---------------------------------------------------------------------

set -euo pipefail

# 1. Locate the repository root and fixed output path
REPO_ROOT="$(git -C "$(dirname "${BASH_SOURCE[0]}")/.." rev-parse --show-toplevel)"
OUT_FILE="${REPO_ROOT}/cmake/CRTMinVersions.cmake"
mkdir -p "$(dirname "${OUT_FILE}")"

# 2. Make sure all submodules (shallow) are checked out
echo "[gen-crt-min-versions] Updating submodules ..."
git -C "${REPO_ROOT}" submodule update --init --recursive --depth 1

# 3. Fetch release tags so we can capture nice version numbers (best-effort)
echo "[gen-crt-min-versions] Fetching tags in submodules ..."
git -C "${REPO_ROOT}" submodule foreach --quiet '
    git fetch --tags origin --depth 1 2>/dev/null || true
'

# 4. Start the output file
cat > "${OUT_FILE}" <<EOF
# DO NOT EDIT BY HAND
# Auto-generated by $(basename "$0") on $(date -u)

EOF

# 5. Walk every submodule, record commit and (if present) the nearest tag
export OUT_FILE        # visible in the foreach subshell
git -C "${REPO_ROOT}" submodule foreach --quiet '
    short_name=$(basename "$sm_path")                               # e.g. aws-c-io
    cmake_sym=$(echo "$short_name" | tr "[:lower:]-" "[:upper:]_")  # AWS_C_IO
    commit="$sha1"                                                  # pinned SHA
    tag=$(git describe --tags --abbrev=0 2>/dev/null || true)       # may be empty

    {
        if [[ -n "$tag" ]]; then
            ver=${tag#v}
            printf "set(MIN_%s_VERSION %s)\n"  "$cmake_sym" "$ver"
        fi
        printf "set(MIN_%s_COMMIT  %s)\n\n"  "$cmake_sym" "$commit"
    } >> "${OUT_FILE}"
'

echo "[gen-crt-min-versions] Wrote ${OUT_FILE}"
